/*
@file		Application.cpp
@author		autogen
@version	1.0
@date		02/02/2021 22:29:40 (Rendered)
@brief		Short
@details	Details
@copyright	(c) 2015 mail at klaus - liebler . de === GNU GPL v3
 */


eAppCallResult cApplication::OnCommand(eCommandType cmd, const uint8_t * const payload,
		uint8_t payloadLength, SensactContext *ctx) {
	switch(cmd)
	{
	case eCommandType::NOP: OnNOPCommand(ctx); break;
	case eCommandType::RESET: OnRESETCommand(ctx); break;
	case eCommandType::START_IAP: OnSTART_IAPCommand(ctx); break;
	case eCommandType::START: OnSTARTCommand(ctx); break;
	case eCommandType::STOP: OnSTOPCommand(ctx); break;
	case eCommandType::UP: OnUPCommand(payload[0], ctx); break;
	case eCommandType::DOWN: OnDOWNCommand(payload[0], ctx); break;
	case eCommandType::FORWARD: OnFORWARDCommand(ctx); break;
	case eCommandType::BACKWARD: OnBACKWARDCommand(ctx); break;
	case eCommandType::LEFT: OnLEFTCommand(ctx); break;
	case eCommandType::RIGHT: OnRIGHTCommand(ctx); break;
	case eCommandType::ON: OnONCommand(Common::ParseUInt32(payload, 0), ctx); break;
	case eCommandType::ON_FILTER: OnON_FILTERCommand(Common::ParseUInt16(payload, 0), Common::ParseUInt32(payload, 2), ctx); break;
	case eCommandType::OFF: OnOFFCommand(Common::ParseUInt32(payload, 0), ctx); break;
	case eCommandType::TOGGLE: OnTOGGLECommand(ctx); break;
	case eCommandType::TOGGLE_FILTER: OnTOGGLE_FILTERCommand(Common::ParseUInt16(payload, 0), ctx); break;
	case eCommandType::TOGGLE_SPECIAL: OnTOGGLE_SPECIALCommand(ctx); break;
	case eCommandType::SET_PARAM: OnSET_PARAMCommand(ctx); break;
	case eCommandType::SET_HORIZONTAL_TARGET: OnSET_HORIZONTAL_TARGETCommand(Common::ParseUInt16(payload, 0), ctx); break;
	case eCommandType::STEP_HORIZONTAL: OnSTEP_HORIZONTALCommand(Common::ParseInt16(payload, 0), ctx); break;
	case eCommandType::SET_VERTICAL_TARGET: OnSET_VERTICAL_TARGETCommand(Common::ParseUInt16(payload, 0), ctx); break;
	case eCommandType::STEP_VERTICAL: OnSTEP_VERTICALCommand(Common::ParseInt16(payload, 0), ctx); break;
	case eCommandType::SET_LATERAL_TARGET: OnSET_LATERAL_TARGETCommand(Common::ParseUInt16(payload, 0), ctx); break;
	case eCommandType::STEP_LATERAL: OnSTEP_LATERALCommand(Common::ParseInt16(payload, 0), ctx); break;
	case eCommandType::HEARTBEAT: OnHEARTBEATCommand(Common::ParseUInt32(payload, 0), ctx); break;
	case eCommandType::SEND_STATUS: OnSEND_STATUSCommand(ctx); break;
	case eCommandType::SET_RGBW: OnSET_RGBWCommand(payload[0], payload[1], payload[2], payload[3], ctx); break;
	case eCommandType::SET_SIGNAL: OnSET_SIGNALCommand(Common::ParseUInt16(payload, 0), ctx); break;
	case eCommandType::PING: OnPINGCommand(Common::ParseUInt32(payload, 0), ctx); break;
	case eCommandType::DEMO: OnDEMOCommand(Common::ParseUInt32(payload, 0), ctx); break;
	case eCommandType::SET_PWM: OnSET_PWMCommand(Common::ParseUInt32(payload, 0), Common::ParseUInt16(payload, 4), ctx); break;

		default:return eAppCallResult::NOT_IMPLEMENTED;
	}
	UU(payloadLength);
	return eAppCallResult::OK;
}

	bool cApplication::SendNOPCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::NOP, buffer, 0);
	}
	bool cApplication::SendRESETCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::RESET, buffer, 0);
	}
	bool cApplication::SendSTART_IAPCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::START_IAP, buffer, 0);
	}
	bool cApplication::SendSTARTCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::START, buffer, 0);
	}
	bool cApplication::SendSTOPCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::STOP, buffer, 0);
	}
	bool cApplication::SendUPCommand(eApplicationID destinationApp, uint8_t forced, SensactContext *ctx)
	{
		uint8_t buffer[8];
		buffer[0]=forced;
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::UP, buffer, 1);
	}
	bool cApplication::SendDOWNCommand(eApplicationID destinationApp, uint8_t forced, SensactContext *ctx)
	{
		uint8_t buffer[8];
		buffer[0]=forced;
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::DOWN, buffer, 1);
	}
	bool cApplication::SendFORWARDCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::FORWARD, buffer, 0);
	}
	bool cApplication::SendBACKWARDCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::BACKWARD, buffer, 0);
	}
	bool cApplication::SendLEFTCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::LEFT, buffer, 0);
	}
	bool cApplication::SendRIGHTCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::RIGHT, buffer, 0);
	}
	bool cApplication::SendONCommand(eApplicationID destinationApp, uint32_t autoReturnToOffMsecs, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(autoReturnToOffMsecs, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::ON, buffer, 4);
	}
	bool cApplication::SendON_FILTERCommand(eApplicationID destinationApp, uint16_t targetApplicationId, uint32_t autoReturnToOffMsecs, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(targetApplicationId, buffer, 0);
		Common::WriteUInt32(autoReturnToOffMsecs, buffer, 2);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::ON_FILTER, buffer, 6);
	}
	bool cApplication::SendOFFCommand(eApplicationID destinationApp, uint32_t autoReturnToOnMsecs, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(autoReturnToOnMsecs, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::OFF, buffer, 4);
	}
	bool cApplication::SendTOGGLECommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::TOGGLE, buffer, 0);
	}
	bool cApplication::SendTOGGLE_FILTERCommand(eApplicationID destinationApp, uint16_t targetApplicationId, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(targetApplicationId, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::TOGGLE_FILTER, buffer, 2);
	}
	bool cApplication::SendTOGGLE_SPECIALCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::TOGGLE_SPECIAL, buffer, 0);
	}
	bool cApplication::SendSET_PARAMCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_PARAM, buffer, 0);
	}
	bool cApplication::SendSET_HORIZONTAL_TARGETCommand(eApplicationID destinationApp, uint16_t target, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(target, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_HORIZONTAL_TARGET, buffer, 2);
	}
	bool cApplication::SendSTEP_HORIZONTALCommand(eApplicationID destinationApp, int16_t step, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteInt16(step, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::STEP_HORIZONTAL, buffer, 2);
	}
	bool cApplication::SendSET_VERTICAL_TARGETCommand(eApplicationID destinationApp, uint16_t target, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(target, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_VERTICAL_TARGET, buffer, 2);
	}
	bool cApplication::SendSTEP_VERTICALCommand(eApplicationID destinationApp, int16_t step, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteInt16(step, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::STEP_VERTICAL, buffer, 2);
	}
	bool cApplication::SendSET_LATERAL_TARGETCommand(eApplicationID destinationApp, uint16_t target, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(target, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_LATERAL_TARGET, buffer, 2);
	}
	bool cApplication::SendSTEP_LATERALCommand(eApplicationID destinationApp, int16_t step, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteInt16(step, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::STEP_LATERAL, buffer, 2);
	}
	bool cApplication::SendHEARTBEATCommand(eApplicationID destinationApp, uint32_t sender, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(sender, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::HEARTBEAT, buffer, 4);
	}
	bool cApplication::SendSEND_STATUSCommand(eApplicationID destinationApp, SensactContext *ctx)
	{
		uint8_t buffer[8];
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SEND_STATUS, buffer, 0);
	}
	bool cApplication::SendSET_RGBWCommand(eApplicationID destinationApp, uint8_t R, uint8_t G, uint8_t B, uint8_t W, SensactContext *ctx)
	{
		uint8_t buffer[8];
		buffer[0]=R;
		buffer[1]=G;
		buffer[2]=B;
		buffer[3]=W;
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_RGBW, buffer, 4);
	}
	bool cApplication::SendSET_SIGNALCommand(eApplicationID destinationApp, uint16_t signal, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt16(signal, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_SIGNAL, buffer, 2);
	}
	bool cApplication::SendPINGCommand(eApplicationID destinationApp, uint32_t payload, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(payload, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::PING, buffer, 4);
	}
	bool cApplication::SendDEMOCommand(eApplicationID destinationApp, uint32_t demostep, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(demostep, buffer, 0);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::DEMO, buffer, 4);
	}
	bool cApplication::SendSET_PWMCommand(eApplicationID destinationApp, uint32_t bitmask, uint16_t value, SensactContext *ctx)
	{
		uint8_t buffer[8];
		Common::WriteUInt32(bitmask, buffer, 0);
		Common::WriteUInt16(value, buffer, 4);
		return ctx->master->SendCommandToMessageBus(destinationApp, eCommandType::SET_PWM, buffer, 6);
	}


	void cApplication::OnNOPCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command NOP", N());
	}

	void cApplication::OnRESETCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command RESET", N());
	}

	void cApplication::OnSTART_IAPCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command START_IAP", N());
	}

	void cApplication::OnSTARTCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command START", N());
	}

	void cApplication::OnSTOPCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command STOP", N());
	}

	void cApplication::OnUPCommand(uint8_t forced, SensactContext *ctx)
	{
		(void)(forced);
		(void)(ctx);
		LOGE("Application %s does not support Command UP", N());
	}

	void cApplication::OnDOWNCommand(uint8_t forced, SensactContext *ctx)
	{
		(void)(forced);
		(void)(ctx);
		LOGE("Application %s does not support Command DOWN", N());
	}

	void cApplication::OnFORWARDCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command FORWARD", N());
	}

	void cApplication::OnBACKWARDCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command BACKWARD", N());
	}

	void cApplication::OnLEFTCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command LEFT", N());
	}

	void cApplication::OnRIGHTCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command RIGHT", N());
	}

	void cApplication::OnONCommand(uint32_t autoReturnToOffMsecs, SensactContext *ctx)
	{
		(void)(autoReturnToOffMsecs);
		(void)(ctx);
		LOGE("Application %s does not support Command ON", N());
	}

	void cApplication::OnON_FILTERCommand(uint16_t targetApplicationId, uint32_t autoReturnToOffMsecs, SensactContext *ctx)
	{
		(void)(targetApplicationId);
		(void)(autoReturnToOffMsecs);
		(void)(ctx);
		LOGE("Application %s does not support Command ON_FILTER", N());
	}

	void cApplication::OnOFFCommand(uint32_t autoReturnToOnMsecs, SensactContext *ctx)
	{
		(void)(autoReturnToOnMsecs);
		(void)(ctx);
		LOGE("Application %s does not support Command OFF", N());
	}

	void cApplication::OnTOGGLECommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command TOGGLE", N());
	}

	void cApplication::OnTOGGLE_FILTERCommand(uint16_t targetApplicationId, SensactContext *ctx)
	{
		(void)(targetApplicationId);
		(void)(ctx);
		LOGE("Application %s does not support Command TOGGLE_FILTER", N());
	}

	void cApplication::OnTOGGLE_SPECIALCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command TOGGLE_SPECIAL", N());
	}

	void cApplication::OnSET_PARAMCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command SET_PARAM", N());
	}

	void cApplication::OnSET_HORIZONTAL_TARGETCommand(uint16_t target, SensactContext *ctx)
	{
		(void)(target);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_HORIZONTAL_TARGET", N());
	}

	void cApplication::OnSTEP_HORIZONTALCommand(int16_t step, SensactContext *ctx)
	{
		(void)(step);
		(void)(ctx);
		LOGE("Application %s does not support Command STEP_HORIZONTAL", N());
	}

	void cApplication::OnSET_VERTICAL_TARGETCommand(uint16_t target, SensactContext *ctx)
	{
		(void)(target);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_VERTICAL_TARGET", N());
	}

	void cApplication::OnSTEP_VERTICALCommand(int16_t step, SensactContext *ctx)
	{
		(void)(step);
		(void)(ctx);
		LOGE("Application %s does not support Command STEP_VERTICAL", N());
	}

	void cApplication::OnSET_LATERAL_TARGETCommand(uint16_t target, SensactContext *ctx)
	{
		(void)(target);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_LATERAL_TARGET", N());
	}

	void cApplication::OnSTEP_LATERALCommand(int16_t step, SensactContext *ctx)
	{
		(void)(step);
		(void)(ctx);
		LOGE("Application %s does not support Command STEP_LATERAL", N());
	}

	void cApplication::OnHEARTBEATCommand(uint32_t sender, SensactContext *ctx)
	{
		(void)(sender);
		(void)(ctx);
		LOGE("Application %s does not support Command HEARTBEAT", N());
	}

	void cApplication::OnSEND_STATUSCommand(SensactContext *ctx)
	{
		(void)(ctx);
		LOGE("Application %s does not support Command SEND_STATUS", N());
	}

	void cApplication::OnSET_RGBWCommand(uint8_t R, uint8_t G, uint8_t B, uint8_t W, SensactContext *ctx)
	{
		(void)(R);
		(void)(G);
		(void)(B);
		(void)(W);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_RGBW", N());
	}

	void cApplication::OnSET_SIGNALCommand(uint16_t signal, SensactContext *ctx)
	{
		(void)(signal);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_SIGNAL", N());
	}

	void cApplication::OnPINGCommand(uint32_t payload, SensactContext *ctx)
	{
		(void)(payload);
		(void)(ctx);
		LOGE("Application %s does not support Command PING", N());
	}

	void cApplication::OnDEMOCommand(uint32_t demostep, SensactContext *ctx)
	{
		(void)(demostep);
		(void)(ctx);
		LOGE("Application %s does not support Command DEMO", N());
	}

	void cApplication::OnSET_PWMCommand(uint32_t bitmask, uint16_t value, SensactContext *ctx)
	{
		(void)(bitmask);
		(void)(value);
		(void)(ctx);
		LOGE("Application %s does not support Command SET_PWM", N());
	}
