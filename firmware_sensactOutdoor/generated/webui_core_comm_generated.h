// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEBUICORECOMM_SENSACT_COMM_H_
#define FLATBUFFERS_GENERATED_WEBUICORECOMM_SENSACT_COMM_H_

#include "flatbuffers/flatbuffers.h"

namespace sensact {
namespace comm {

struct tBlindState;
struct tBlindStateBuilder;

struct tSinglePwmState;
struct tSinglePwmStateBuilder;

struct tOnOffState;
struct tOnOffStateBuilder;

struct tStateWrapper;
struct tStateWrapperBuilder;

struct tState;
struct tStateBuilder;

struct tBlindCommand;
struct tBlindCommandBuilder;

struct tSinglePwmCommand;
struct tSinglePwmCommandBuilder;

struct tOnOffCommand;
struct tOnOffCommandBuilder;

struct tCommand;
struct tCommandBuilder;

struct tBlindConfig;
struct tBlindConfigBuilder;

struct tSinglePwmConfig;
struct tSinglePwmConfigBuilder;

struct tOnOffConfig;
struct tOnOffConfigBuilder;

struct tConfigWrapper;
struct tConfigWrapperBuilder;

struct tIoConfig;
struct tIoConfigBuilder;

enum eBlindState {
  eBlindState_STOP = 0,
  eBlindState_UP = 1,
  eBlindState_DOWN = 2,
  eBlindState_PREPARE = 3,
  eBlindState_MIN = eBlindState_STOP,
  eBlindState_MAX = eBlindState_PREPARE
};

inline const eBlindState (&EnumValueseBlindState())[4] {
  static const eBlindState values[] = {
    eBlindState_STOP,
    eBlindState_UP,
    eBlindState_DOWN,
    eBlindState_PREPARE
  };
  return values;
}

inline const char * const *EnumNameseBlindState() {
  static const char * const names[5] = {
    "STOP",
    "UP",
    "DOWN",
    "PREPARE",
    nullptr
  };
  return names;
}

inline const char *EnumNameeBlindState(eBlindState e) {
  if (flatbuffers::IsOutRange(e, eBlindState_STOP, eBlindState_PREPARE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseBlindState()[index];
}

enum eBlindCommand {
  eBlindCommand_STOP = 0,
  eBlindCommand_UP = 1,
  eBlindCommand_DOWN = 2,
  eBlindCommand_MIN = eBlindCommand_STOP,
  eBlindCommand_MAX = eBlindCommand_DOWN
};

inline const eBlindCommand (&EnumValueseBlindCommand())[3] {
  static const eBlindCommand values[] = {
    eBlindCommand_STOP,
    eBlindCommand_UP,
    eBlindCommand_DOWN
  };
  return values;
}

inline const char * const *EnumNameseBlindCommand() {
  static const char * const names[4] = {
    "STOP",
    "UP",
    "DOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameeBlindCommand(eBlindCommand e) {
  if (flatbuffers::IsOutRange(e, eBlindCommand_STOP, eBlindCommand_DOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseBlindCommand()[index];
}

enum eSinglePwmCommand {
  eSinglePwmCommand_TOGGLE = 0,
  eSinglePwmCommand_CHANGE_INTENSITY = 1,
  eSinglePwmCommand_MIN = eSinglePwmCommand_TOGGLE,
  eSinglePwmCommand_MAX = eSinglePwmCommand_CHANGE_INTENSITY
};

inline const eSinglePwmCommand (&EnumValueseSinglePwmCommand())[2] {
  static const eSinglePwmCommand values[] = {
    eSinglePwmCommand_TOGGLE,
    eSinglePwmCommand_CHANGE_INTENSITY
  };
  return values;
}

inline const char * const *EnumNameseSinglePwmCommand() {
  static const char * const names[3] = {
    "TOGGLE",
    "CHANGE_INTENSITY",
    nullptr
  };
  return names;
}

inline const char *EnumNameeSinglePwmCommand(eSinglePwmCommand e) {
  if (flatbuffers::IsOutRange(e, eSinglePwmCommand_TOGGLE, eSinglePwmCommand_CHANGE_INTENSITY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseSinglePwmCommand()[index];
}

enum eOnOffCommand {
  eOnOffCommand_ON = 0,
  eOnOffCommand_AUTO = 1,
  eOnOffCommand_OFF = 2,
  eOnOffCommand_TRIGGER = 3,
  eOnOffCommand_TRIGGER_MSECS = 4,
  eOnOffCommand_MIN = eOnOffCommand_ON,
  eOnOffCommand_MAX = eOnOffCommand_TRIGGER_MSECS
};

inline const eOnOffCommand (&EnumValueseOnOffCommand())[5] {
  static const eOnOffCommand values[] = {
    eOnOffCommand_ON,
    eOnOffCommand_AUTO,
    eOnOffCommand_OFF,
    eOnOffCommand_TRIGGER,
    eOnOffCommand_TRIGGER_MSECS
  };
  return values;
}

inline const char * const *EnumNameseOnOffCommand() {
  static const char * const names[6] = {
    "ON",
    "AUTO",
    "OFF",
    "TRIGGER",
    "TRIGGER_MSECS",
    nullptr
  };
  return names;
}

inline const char *EnumNameeOnOffCommand(eOnOffCommand e) {
  if (flatbuffers::IsOutRange(e, eOnOffCommand_ON, eOnOffCommand_TRIGGER_MSECS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseOnOffCommand()[index];
}

enum eOnOffState {
  eOnOffState_MANUAL_OFF = 0,
  eOnOffState_MANUAL_ON = 1,
  eOnOffState_AUTO_OFF = 2,
  eOnOffState_AUTO_ON = 3,
  eOnOffState_MIN = eOnOffState_MANUAL_OFF,
  eOnOffState_MAX = eOnOffState_AUTO_ON
};

inline const eOnOffState (&EnumValueseOnOffState())[4] {
  static const eOnOffState values[] = {
    eOnOffState_MANUAL_OFF,
    eOnOffState_MANUAL_ON,
    eOnOffState_AUTO_OFF,
    eOnOffState_AUTO_ON
  };
  return values;
}

inline const char * const *EnumNameseOnOffState() {
  static const char * const names[5] = {
    "MANUAL_OFF",
    "MANUAL_ON",
    "AUTO_OFF",
    "AUTO_ON",
    nullptr
  };
  return names;
}

inline const char *EnumNameeOnOffState(eOnOffState e) {
  if (flatbuffers::IsOutRange(e, eOnOffState_MANUAL_OFF, eOnOffState_AUTO_ON)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseOnOffState()[index];
}

enum uState {
  uState_NONE = 0,
  uState_tBlindState = 1,
  uState_tSinglePwmState = 2,
  uState_tOnOffState = 3,
  uState_MIN = uState_NONE,
  uState_MAX = uState_tOnOffState
};

inline const uState (&EnumValuesuState())[4] {
  static const uState values[] = {
    uState_NONE,
    uState_tBlindState,
    uState_tSinglePwmState,
    uState_tOnOffState
  };
  return values;
}

inline const char * const *EnumNamesuState() {
  static const char * const names[5] = {
    "NONE",
    "tBlindState",
    "tSinglePwmState",
    "tOnOffState",
    nullptr
  };
  return names;
}

inline const char *EnumNameuState(uState e) {
  if (flatbuffers::IsOutRange(e, uState_NONE, uState_tOnOffState)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesuState()[index];
}

template<typename T> struct uStateTraits {
  static const uState enum_value = uState_NONE;
};

template<> struct uStateTraits<sensact::comm::tBlindState> {
  static const uState enum_value = uState_tBlindState;
};

template<> struct uStateTraits<sensact::comm::tSinglePwmState> {
  static const uState enum_value = uState_tSinglePwmState;
};

template<> struct uStateTraits<sensact::comm::tOnOffState> {
  static const uState enum_value = uState_tOnOffState;
};

bool VerifyuState(flatbuffers::Verifier &verifier, const void *obj, uState type);
bool VerifyuStateVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum uCommand {
  uCommand_NONE = 0,
  uCommand_tBlindCommand = 1,
  uCommand_tSinglePwmCommand = 2,
  uCommand_tOnOffCommand = 3,
  uCommand_MIN = uCommand_NONE,
  uCommand_MAX = uCommand_tOnOffCommand
};

inline const uCommand (&EnumValuesuCommand())[4] {
  static const uCommand values[] = {
    uCommand_NONE,
    uCommand_tBlindCommand,
    uCommand_tSinglePwmCommand,
    uCommand_tOnOffCommand
  };
  return values;
}

inline const char * const *EnumNamesuCommand() {
  static const char * const names[5] = {
    "NONE",
    "tBlindCommand",
    "tSinglePwmCommand",
    "tOnOffCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameuCommand(uCommand e) {
  if (flatbuffers::IsOutRange(e, uCommand_NONE, uCommand_tOnOffCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesuCommand()[index];
}

template<typename T> struct uCommandTraits {
  static const uCommand enum_value = uCommand_NONE;
};

template<> struct uCommandTraits<sensact::comm::tBlindCommand> {
  static const uCommand enum_value = uCommand_tBlindCommand;
};

template<> struct uCommandTraits<sensact::comm::tSinglePwmCommand> {
  static const uCommand enum_value = uCommand_tSinglePwmCommand;
};

template<> struct uCommandTraits<sensact::comm::tOnOffCommand> {
  static const uCommand enum_value = uCommand_tOnOffCommand;
};

bool VerifyuCommand(flatbuffers::Verifier &verifier, const void *obj, uCommand type);
bool VerifyuCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum eRelayInterlockMode {
  eRelayInterlockMode_RELAY1_UP__RELAY2_DOWN = 0,
  eRelayInterlockMode_RELAY1_DOWN__RELAY2_UP = 1,
  eRelayInterlockMode_RELAY1_POWER__RELAY2_UP = 2,
  eRelayInterlockMode_RELAY1_POWER__RELAY2_DOWN = 3,
  eRelayInterlockMode_RELAY1_UP__RELAY2_POWER = 4,
  eRelayInterlockMode_RELAY1_DOWN__RELAY2_POWER = 5,
  eRelayInterlockMode_MIN = eRelayInterlockMode_RELAY1_UP__RELAY2_DOWN,
  eRelayInterlockMode_MAX = eRelayInterlockMode_RELAY1_DOWN__RELAY2_POWER
};

inline const eRelayInterlockMode (&EnumValueseRelayInterlockMode())[6] {
  static const eRelayInterlockMode values[] = {
    eRelayInterlockMode_RELAY1_UP__RELAY2_DOWN,
    eRelayInterlockMode_RELAY1_DOWN__RELAY2_UP,
    eRelayInterlockMode_RELAY1_POWER__RELAY2_UP,
    eRelayInterlockMode_RELAY1_POWER__RELAY2_DOWN,
    eRelayInterlockMode_RELAY1_UP__RELAY2_POWER,
    eRelayInterlockMode_RELAY1_DOWN__RELAY2_POWER
  };
  return values;
}

inline const char * const *EnumNameseRelayInterlockMode() {
  static const char * const names[7] = {
    "RELAY1_UP__RELAY2_DOWN",
    "RELAY1_DOWN__RELAY2_UP",
    "RELAY1_POWER__RELAY2_UP",
    "RELAY1_POWER__RELAY2_DOWN",
    "RELAY1_UP__RELAY2_POWER",
    "RELAY1_DOWN__RELAY2_POWER",
    nullptr
  };
  return names;
}

inline const char *EnumNameeRelayInterlockMode(eRelayInterlockMode e) {
  if (flatbuffers::IsOutRange(e, eRelayInterlockMode_RELAY1_UP__RELAY2_DOWN, eRelayInterlockMode_RELAY1_DOWN__RELAY2_POWER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameseRelayInterlockMode()[index];
}

enum uConfig {
  uConfig_NONE = 0,
  uConfig_tBlindConfig = 1,
  uConfig_tSinglePwmConfig = 2,
  uConfig_tOnOffConfig = 3,
  uConfig_MIN = uConfig_NONE,
  uConfig_MAX = uConfig_tOnOffConfig
};

inline const uConfig (&EnumValuesuConfig())[4] {
  static const uConfig values[] = {
    uConfig_NONE,
    uConfig_tBlindConfig,
    uConfig_tSinglePwmConfig,
    uConfig_tOnOffConfig
  };
  return values;
}

inline const char * const *EnumNamesuConfig() {
  static const char * const names[5] = {
    "NONE",
    "tBlindConfig",
    "tSinglePwmConfig",
    "tOnOffConfig",
    nullptr
  };
  return names;
}

inline const char *EnumNameuConfig(uConfig e) {
  if (flatbuffers::IsOutRange(e, uConfig_NONE, uConfig_tOnOffConfig)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesuConfig()[index];
}

template<typename T> struct uConfigTraits {
  static const uConfig enum_value = uConfig_NONE;
};

template<> struct uConfigTraits<sensact::comm::tBlindConfig> {
  static const uConfig enum_value = uConfig_tBlindConfig;
};

template<> struct uConfigTraits<sensact::comm::tSinglePwmConfig> {
  static const uConfig enum_value = uConfig_tSinglePwmConfig;
};

template<> struct uConfigTraits<sensact::comm::tOnOffConfig> {
  static const uConfig enum_value = uConfig_tOnOffConfig;
};

bool VerifyuConfig(flatbuffers::Verifier &verifier, const void *obj, uConfig type);
bool VerifyuConfigVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct tBlindState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tBlindStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4,
    VT_STATE = 6
  };
  uint16_t position() const {
    return GetField<uint16_t>(VT_POSITION, 0);
  }
  sensact::comm::eBlindState state() const {
    return static_cast<sensact::comm::eBlindState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_POSITION) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct tBlindStateBuilder {
  typedef tBlindState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint16_t position) {
    fbb_.AddElement<uint16_t>(tBlindState::VT_POSITION, position, 0);
  }
  void add_state(sensact::comm::eBlindState state) {
    fbb_.AddElement<int8_t>(tBlindState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit tBlindStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tBlindStateBuilder &operator=(const tBlindStateBuilder &);
  flatbuffers::Offset<tBlindState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tBlindState>(end);
    return o;
  }
};

inline flatbuffers::Offset<tBlindState> CreatetBlindState(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t position = 0,
    sensact::comm::eBlindState state = sensact::comm::eBlindState_STOP) {
  tBlindStateBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_state(state);
  return builder_.Finish();
}

struct tSinglePwmState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tSinglePwmStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTENSITY0_100 = 4,
    VT_ON = 6
  };
  uint8_t intensity0_100() const {
    return GetField<uint8_t>(VT_INTENSITY0_100, 0);
  }
  bool on() const {
    return GetField<uint8_t>(VT_ON, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INTENSITY0_100) &&
           VerifyField<uint8_t>(verifier, VT_ON) &&
           verifier.EndTable();
  }
};

struct tSinglePwmStateBuilder {
  typedef tSinglePwmState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_intensity0_100(uint8_t intensity0_100) {
    fbb_.AddElement<uint8_t>(tSinglePwmState::VT_INTENSITY0_100, intensity0_100, 0);
  }
  void add_on(bool on) {
    fbb_.AddElement<uint8_t>(tSinglePwmState::VT_ON, static_cast<uint8_t>(on), 0);
  }
  explicit tSinglePwmStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tSinglePwmStateBuilder &operator=(const tSinglePwmStateBuilder &);
  flatbuffers::Offset<tSinglePwmState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tSinglePwmState>(end);
    return o;
  }
};

inline flatbuffers::Offset<tSinglePwmState> CreatetSinglePwmState(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t intensity0_100 = 0,
    bool on = false) {
  tSinglePwmStateBuilder builder_(_fbb);
  builder_.add_on(on);
  builder_.add_intensity0_100(intensity0_100);
  return builder_.Finish();
}

struct tOnOffState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tOnOffStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  sensact::comm::eOnOffState state() const {
    return static_cast<sensact::comm::eOnOffState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct tOnOffStateBuilder {
  typedef tOnOffState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_state(sensact::comm::eOnOffState state) {
    fbb_.AddElement<int8_t>(tOnOffState::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit tOnOffStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tOnOffStateBuilder &operator=(const tOnOffStateBuilder &);
  flatbuffers::Offset<tOnOffState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tOnOffState>(end);
    return o;
  }
};

inline flatbuffers::Offset<tOnOffState> CreatetOnOffState(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eOnOffState state = sensact::comm::eOnOffState_MANUAL_OFF) {
  tOnOffStateBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

struct tStateWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStateWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATIONID = 4,
    VT_STATE_TYPE = 6,
    VT_STATE = 8
  };
  uint32_t applicationId() const {
    return GetField<uint32_t>(VT_APPLICATIONID, 0);
  }
  sensact::comm::uState state_type() const {
    return static_cast<sensact::comm::uState>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const sensact::comm::tBlindState *state_as_tBlindState() const {
    return state_type() == sensact::comm::uState_tBlindState ? static_cast<const sensact::comm::tBlindState *>(state()) : nullptr;
  }
  const sensact::comm::tSinglePwmState *state_as_tSinglePwmState() const {
    return state_type() == sensact::comm::uState_tSinglePwmState ? static_cast<const sensact::comm::tSinglePwmState *>(state()) : nullptr;
  }
  const sensact::comm::tOnOffState *state_as_tOnOffState() const {
    return state_type() == sensact::comm::uState_tOnOffState ? static_cast<const sensact::comm::tOnOffState *>(state()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_APPLICATIONID) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyuState(verifier, state(), state_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sensact::comm::tBlindState *tStateWrapper::state_as<sensact::comm::tBlindState>() const {
  return state_as_tBlindState();
}

template<> inline const sensact::comm::tSinglePwmState *tStateWrapper::state_as<sensact::comm::tSinglePwmState>() const {
  return state_as_tSinglePwmState();
}

template<> inline const sensact::comm::tOnOffState *tStateWrapper::state_as<sensact::comm::tOnOffState>() const {
  return state_as_tOnOffState();
}

struct tStateWrapperBuilder {
  typedef tStateWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_applicationId(uint32_t applicationId) {
    fbb_.AddElement<uint32_t>(tStateWrapper::VT_APPLICATIONID, applicationId, 0);
  }
  void add_state_type(sensact::comm::uState state_type) {
    fbb_.AddElement<uint8_t>(tStateWrapper::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(flatbuffers::Offset<void> state) {
    fbb_.AddOffset(tStateWrapper::VT_STATE, state);
  }
  explicit tStateWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStateWrapperBuilder &operator=(const tStateWrapperBuilder &);
  flatbuffers::Offset<tStateWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tStateWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<tStateWrapper> CreatetStateWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t applicationId = 0,
    sensact::comm::uState state_type = sensact::comm::uState_NONE,
    flatbuffers::Offset<void> state = 0) {
  tStateWrapperBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_applicationId(applicationId);
  builder_.add_state_type(state_type);
  return builder_.Finish();
}

struct tState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_STATES = 6
  };
  uint32_t timestamp() const {
    return GetField<uint32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tStateWrapper>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tStateWrapper>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
};

struct tStateBuilder {
  typedef tState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(uint32_t timestamp) {
    fbb_.AddElement<uint32_t>(tState::VT_TIMESTAMP, timestamp, 0);
  }
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tStateWrapper>>> states) {
    fbb_.AddOffset(tState::VT_STATES, states);
  }
  explicit tStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tStateBuilder &operator=(const tStateBuilder &);
  flatbuffers::Offset<tState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tState>(end);
    return o;
  }
};

inline flatbuffers::Offset<tState> CreatetState(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tStateWrapper>>> states = 0) {
  tStateBuilder builder_(_fbb);
  builder_.add_states(states);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<tState> CreatetStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    const std::vector<flatbuffers::Offset<sensact::comm::tStateWrapper>> *states = nullptr) {
  auto states__ = states ? _fbb.CreateVector<flatbuffers::Offset<sensact::comm::tStateWrapper>>(*states) : 0;
  return sensact::comm::CreatetState(
      _fbb,
      timestamp,
      states__);
}

struct tBlindCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tBlindCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4
  };
  sensact::comm::eBlindCommand cmd() const {
    return static_cast<sensact::comm::eBlindCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           verifier.EndTable();
  }
};

struct tBlindCommandBuilder {
  typedef tBlindCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eBlindCommand cmd) {
    fbb_.AddElement<int8_t>(tBlindCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  explicit tBlindCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tBlindCommandBuilder &operator=(const tBlindCommandBuilder &);
  flatbuffers::Offset<tBlindCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tBlindCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tBlindCommand> CreatetBlindCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eBlindCommand cmd = sensact::comm::eBlindCommand_STOP) {
  tBlindCommandBuilder builder_(_fbb);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tSinglePwmCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tSinglePwmCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_INTENSITY0_100 = 6
  };
  sensact::comm::eSinglePwmCommand cmd() const {
    return static_cast<sensact::comm::eSinglePwmCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  uint8_t intensity0_100() const {
    return GetField<uint8_t>(VT_INTENSITY0_100, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<uint8_t>(verifier, VT_INTENSITY0_100) &&
           verifier.EndTable();
  }
};

struct tSinglePwmCommandBuilder {
  typedef tSinglePwmCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eSinglePwmCommand cmd) {
    fbb_.AddElement<int8_t>(tSinglePwmCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_intensity0_100(uint8_t intensity0_100) {
    fbb_.AddElement<uint8_t>(tSinglePwmCommand::VT_INTENSITY0_100, intensity0_100, 0);
  }
  explicit tSinglePwmCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tSinglePwmCommandBuilder &operator=(const tSinglePwmCommandBuilder &);
  flatbuffers::Offset<tSinglePwmCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tSinglePwmCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tSinglePwmCommand> CreatetSinglePwmCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eSinglePwmCommand cmd = sensact::comm::eSinglePwmCommand_TOGGLE,
    uint8_t intensity0_100 = 0) {
  tSinglePwmCommandBuilder builder_(_fbb);
  builder_.add_intensity0_100(intensity0_100);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tOnOffCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tOnOffCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD = 4,
    VT_MSECS = 6
  };
  sensact::comm::eOnOffCommand cmd() const {
    return static_cast<sensact::comm::eOnOffCommand>(GetField<int8_t>(VT_CMD, 0));
  }
  uint32_t msecs() const {
    return GetField<uint32_t>(VT_MSECS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CMD) &&
           VerifyField<uint32_t>(verifier, VT_MSECS) &&
           verifier.EndTable();
  }
};

struct tOnOffCommandBuilder {
  typedef tOnOffCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cmd(sensact::comm::eOnOffCommand cmd) {
    fbb_.AddElement<int8_t>(tOnOffCommand::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_msecs(uint32_t msecs) {
    fbb_.AddElement<uint32_t>(tOnOffCommand::VT_MSECS, msecs, 0);
  }
  explicit tOnOffCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tOnOffCommandBuilder &operator=(const tOnOffCommandBuilder &);
  flatbuffers::Offset<tOnOffCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tOnOffCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tOnOffCommand> CreatetOnOffCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::eOnOffCommand cmd = sensact::comm::eOnOffCommand_ON,
    uint32_t msecs = 0) {
  tOnOffCommandBuilder builder_(_fbb);
  builder_.add_msecs(msecs);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

struct tCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATIONID = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8
  };
  uint32_t applicationId() const {
    return GetField<uint32_t>(VT_APPLICATIONID, 0);
  }
  sensact::comm::uCommand command_type() const {
    return static_cast<sensact::comm::uCommand>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const sensact::comm::tBlindCommand *command_as_tBlindCommand() const {
    return command_type() == sensact::comm::uCommand_tBlindCommand ? static_cast<const sensact::comm::tBlindCommand *>(command()) : nullptr;
  }
  const sensact::comm::tSinglePwmCommand *command_as_tSinglePwmCommand() const {
    return command_type() == sensact::comm::uCommand_tSinglePwmCommand ? static_cast<const sensact::comm::tSinglePwmCommand *>(command()) : nullptr;
  }
  const sensact::comm::tOnOffCommand *command_as_tOnOffCommand() const {
    return command_type() == sensact::comm::uCommand_tOnOffCommand ? static_cast<const sensact::comm::tOnOffCommand *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_APPLICATIONID) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyuCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sensact::comm::tBlindCommand *tCommand::command_as<sensact::comm::tBlindCommand>() const {
  return command_as_tBlindCommand();
}

template<> inline const sensact::comm::tSinglePwmCommand *tCommand::command_as<sensact::comm::tSinglePwmCommand>() const {
  return command_as_tSinglePwmCommand();
}

template<> inline const sensact::comm::tOnOffCommand *tCommand::command_as<sensact::comm::tOnOffCommand>() const {
  return command_as_tOnOffCommand();
}

struct tCommandBuilder {
  typedef tCommand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_applicationId(uint32_t applicationId) {
    fbb_.AddElement<uint32_t>(tCommand::VT_APPLICATIONID, applicationId, 0);
  }
  void add_command_type(sensact::comm::uCommand command_type) {
    fbb_.AddElement<uint8_t>(tCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(tCommand::VT_COMMAND, command);
  }
  explicit tCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tCommandBuilder &operator=(const tCommandBuilder &);
  flatbuffers::Offset<tCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<tCommand> CreatetCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t applicationId = 0,
    sensact::comm::uCommand command_type = sensact::comm::uCommand_NONE,
    flatbuffers::Offset<void> command = 0) {
  tCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_applicationId(applicationId);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct tBlindConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tBlindConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELAY1 = 4,
    VT_RELAY2 = 6,
    VT_MODE = 8,
    VT_TIME_UP_MSECS = 10,
    VT_TIME_DOWN_MSECS = 12
  };
  uint16_t relay1() const {
    return GetField<uint16_t>(VT_RELAY1, 0);
  }
  uint16_t relay2() const {
    return GetField<uint16_t>(VT_RELAY2, 0);
  }
  sensact::comm::eRelayInterlockMode mode() const {
    return static_cast<sensact::comm::eRelayInterlockMode>(GetField<int8_t>(VT_MODE, 0));
  }
  uint32_t time_up_msecs() const {
    return GetField<uint32_t>(VT_TIME_UP_MSECS, 0);
  }
  uint32_t time_down_msecs() const {
    return GetField<uint32_t>(VT_TIME_DOWN_MSECS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_RELAY1) &&
           VerifyField<uint16_t>(verifier, VT_RELAY2) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint32_t>(verifier, VT_TIME_UP_MSECS) &&
           VerifyField<uint32_t>(verifier, VT_TIME_DOWN_MSECS) &&
           verifier.EndTable();
  }
};

struct tBlindConfigBuilder {
  typedef tBlindConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relay1(uint16_t relay1) {
    fbb_.AddElement<uint16_t>(tBlindConfig::VT_RELAY1, relay1, 0);
  }
  void add_relay2(uint16_t relay2) {
    fbb_.AddElement<uint16_t>(tBlindConfig::VT_RELAY2, relay2, 0);
  }
  void add_mode(sensact::comm::eRelayInterlockMode mode) {
    fbb_.AddElement<int8_t>(tBlindConfig::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_time_up_msecs(uint32_t time_up_msecs) {
    fbb_.AddElement<uint32_t>(tBlindConfig::VT_TIME_UP_MSECS, time_up_msecs, 0);
  }
  void add_time_down_msecs(uint32_t time_down_msecs) {
    fbb_.AddElement<uint32_t>(tBlindConfig::VT_TIME_DOWN_MSECS, time_down_msecs, 0);
  }
  explicit tBlindConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tBlindConfigBuilder &operator=(const tBlindConfigBuilder &);
  flatbuffers::Offset<tBlindConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tBlindConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<tBlindConfig> CreatetBlindConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t relay1 = 0,
    uint16_t relay2 = 0,
    sensact::comm::eRelayInterlockMode mode = sensact::comm::eRelayInterlockMode_RELAY1_UP__RELAY2_DOWN,
    uint32_t time_up_msecs = 0,
    uint32_t time_down_msecs = 0) {
  tBlindConfigBuilder builder_(_fbb);
  builder_.add_time_down_msecs(time_down_msecs);
  builder_.add_time_up_msecs(time_up_msecs);
  builder_.add_relay2(relay2);
  builder_.add_relay1(relay1);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct tSinglePwmConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tSinglePwmConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PWMFIRST = 4,
    VT_PWMLAST = 6,
    VT_IDOFSTANDBYCONTROLLER = 8,
    VT_AUTOOFFMSECS = 10
  };
  uint16_t pwmFirst() const {
    return GetField<uint16_t>(VT_PWMFIRST, 0);
  }
  uint16_t pwmLast() const {
    return GetField<uint16_t>(VT_PWMLAST, 0);
  }
  uint16_t idOfStandbyController() const {
    return GetField<uint16_t>(VT_IDOFSTANDBYCONTROLLER, 0);
  }
  uint32_t autoOffMsecs() const {
    return GetField<uint32_t>(VT_AUTOOFFMSECS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PWMFIRST) &&
           VerifyField<uint16_t>(verifier, VT_PWMLAST) &&
           VerifyField<uint16_t>(verifier, VT_IDOFSTANDBYCONTROLLER) &&
           VerifyField<uint32_t>(verifier, VT_AUTOOFFMSECS) &&
           verifier.EndTable();
  }
};

struct tSinglePwmConfigBuilder {
  typedef tSinglePwmConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pwmFirst(uint16_t pwmFirst) {
    fbb_.AddElement<uint16_t>(tSinglePwmConfig::VT_PWMFIRST, pwmFirst, 0);
  }
  void add_pwmLast(uint16_t pwmLast) {
    fbb_.AddElement<uint16_t>(tSinglePwmConfig::VT_PWMLAST, pwmLast, 0);
  }
  void add_idOfStandbyController(uint16_t idOfStandbyController) {
    fbb_.AddElement<uint16_t>(tSinglePwmConfig::VT_IDOFSTANDBYCONTROLLER, idOfStandbyController, 0);
  }
  void add_autoOffMsecs(uint32_t autoOffMsecs) {
    fbb_.AddElement<uint32_t>(tSinglePwmConfig::VT_AUTOOFFMSECS, autoOffMsecs, 0);
  }
  explicit tSinglePwmConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tSinglePwmConfigBuilder &operator=(const tSinglePwmConfigBuilder &);
  flatbuffers::Offset<tSinglePwmConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tSinglePwmConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<tSinglePwmConfig> CreatetSinglePwmConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t pwmFirst = 0,
    uint16_t pwmLast = 0,
    uint16_t idOfStandbyController = 0,
    uint32_t autoOffMsecs = 0) {
  tSinglePwmConfigBuilder builder_(_fbb);
  builder_.add_autoOffMsecs(autoOffMsecs);
  builder_.add_idOfStandbyController(idOfStandbyController);
  builder_.add_pwmLast(pwmLast);
  builder_.add_pwmFirst(pwmFirst);
  return builder_.Finish();
}

struct tOnOffConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tOnOffConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELAY = 4,
    VT_AUTOOFFMSECS = 6,
    VT_INITIALSTATE = 8
  };
  uint16_t relay() const {
    return GetField<uint16_t>(VT_RELAY, 0);
  }
  uint32_t autoOffMsecs() const {
    return GetField<uint32_t>(VT_AUTOOFFMSECS, 0);
  }
  sensact::comm::eOnOffState initialState() const {
    return static_cast<sensact::comm::eOnOffState>(GetField<int8_t>(VT_INITIALSTATE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_RELAY) &&
           VerifyField<uint32_t>(verifier, VT_AUTOOFFMSECS) &&
           VerifyField<int8_t>(verifier, VT_INITIALSTATE) &&
           verifier.EndTable();
  }
};

struct tOnOffConfigBuilder {
  typedef tOnOffConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relay(uint16_t relay) {
    fbb_.AddElement<uint16_t>(tOnOffConfig::VT_RELAY, relay, 0);
  }
  void add_autoOffMsecs(uint32_t autoOffMsecs) {
    fbb_.AddElement<uint32_t>(tOnOffConfig::VT_AUTOOFFMSECS, autoOffMsecs, 0);
  }
  void add_initialState(sensact::comm::eOnOffState initialState) {
    fbb_.AddElement<int8_t>(tOnOffConfig::VT_INITIALSTATE, static_cast<int8_t>(initialState), 0);
  }
  explicit tOnOffConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tOnOffConfigBuilder &operator=(const tOnOffConfigBuilder &);
  flatbuffers::Offset<tOnOffConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tOnOffConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<tOnOffConfig> CreatetOnOffConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t relay = 0,
    uint32_t autoOffMsecs = 0,
    sensact::comm::eOnOffState initialState = sensact::comm::eOnOffState_MANUAL_OFF) {
  tOnOffConfigBuilder builder_(_fbb);
  builder_.add_autoOffMsecs(autoOffMsecs);
  builder_.add_relay(relay);
  builder_.add_initialState(initialState);
  return builder_.Finish();
}

struct tConfigWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tConfigWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG_TYPE = 4,
    VT_CONFIG = 6
  };
  sensact::comm::uConfig config_type() const {
    return static_cast<sensact::comm::uConfig>(GetField<uint8_t>(VT_CONFIG_TYPE, 0));
  }
  const void *config() const {
    return GetPointer<const void *>(VT_CONFIG);
  }
  template<typename T> const T *config_as() const;
  const sensact::comm::tBlindConfig *config_as_tBlindConfig() const {
    return config_type() == sensact::comm::uConfig_tBlindConfig ? static_cast<const sensact::comm::tBlindConfig *>(config()) : nullptr;
  }
  const sensact::comm::tSinglePwmConfig *config_as_tSinglePwmConfig() const {
    return config_type() == sensact::comm::uConfig_tSinglePwmConfig ? static_cast<const sensact::comm::tSinglePwmConfig *>(config()) : nullptr;
  }
  const sensact::comm::tOnOffConfig *config_as_tOnOffConfig() const {
    return config_type() == sensact::comm::uConfig_tOnOffConfig ? static_cast<const sensact::comm::tOnOffConfig *>(config()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONFIG_TYPE) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           VerifyuConfig(verifier, config(), config_type()) &&
           verifier.EndTable();
  }
};

template<> inline const sensact::comm::tBlindConfig *tConfigWrapper::config_as<sensact::comm::tBlindConfig>() const {
  return config_as_tBlindConfig();
}

template<> inline const sensact::comm::tSinglePwmConfig *tConfigWrapper::config_as<sensact::comm::tSinglePwmConfig>() const {
  return config_as_tSinglePwmConfig();
}

template<> inline const sensact::comm::tOnOffConfig *tConfigWrapper::config_as<sensact::comm::tOnOffConfig>() const {
  return config_as_tOnOffConfig();
}

struct tConfigWrapperBuilder {
  typedef tConfigWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config_type(sensact::comm::uConfig config_type) {
    fbb_.AddElement<uint8_t>(tConfigWrapper::VT_CONFIG_TYPE, static_cast<uint8_t>(config_type), 0);
  }
  void add_config(flatbuffers::Offset<void> config) {
    fbb_.AddOffset(tConfigWrapper::VT_CONFIG, config);
  }
  explicit tConfigWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tConfigWrapperBuilder &operator=(const tConfigWrapperBuilder &);
  flatbuffers::Offset<tConfigWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tConfigWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<tConfigWrapper> CreatetConfigWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    sensact::comm::uConfig config_type = sensact::comm::uConfig_NONE,
    flatbuffers::Offset<void> config = 0) {
  tConfigWrapperBuilder builder_(_fbb);
  builder_.add_config(config);
  builder_.add_config_type(config_type);
  return builder_.Finish();
}

struct tIoConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef tIoConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_CONFIGS = 6
  };
  uint32_t timestamp() const {
    return GetField<uint32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tConfigWrapper>> *configs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tConfigWrapper>> *>(VT_CONFIGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_CONFIGS) &&
           verifier.VerifyVector(configs()) &&
           verifier.VerifyVectorOfTables(configs()) &&
           verifier.EndTable();
  }
};

struct tIoConfigBuilder {
  typedef tIoConfig Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(uint32_t timestamp) {
    fbb_.AddElement<uint32_t>(tIoConfig::VT_TIMESTAMP, timestamp, 0);
  }
  void add_configs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tConfigWrapper>>> configs) {
    fbb_.AddOffset(tIoConfig::VT_CONFIGS, configs);
  }
  explicit tIoConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  tIoConfigBuilder &operator=(const tIoConfigBuilder &);
  flatbuffers::Offset<tIoConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<tIoConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<tIoConfig> CreatetIoConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<sensact::comm::tConfigWrapper>>> configs = 0) {
  tIoConfigBuilder builder_(_fbb);
  builder_.add_configs(configs);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<tIoConfig> CreatetIoConfigDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t timestamp = 0,
    const std::vector<flatbuffers::Offset<sensact::comm::tConfigWrapper>> *configs = nullptr) {
  auto configs__ = configs ? _fbb.CreateVector<flatbuffers::Offset<sensact::comm::tConfigWrapper>>(*configs) : 0;
  return sensact::comm::CreatetIoConfig(
      _fbb,
      timestamp,
      configs__);
}

inline bool VerifyuState(flatbuffers::Verifier &verifier, const void *obj, uState type) {
  switch (type) {
    case uState_NONE: {
      return true;
    }
    case uState_tBlindState: {
      auto ptr = reinterpret_cast<const sensact::comm::tBlindState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uState_tSinglePwmState: {
      auto ptr = reinterpret_cast<const sensact::comm::tSinglePwmState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uState_tOnOffState: {
      auto ptr = reinterpret_cast<const sensact::comm::tOnOffState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyuStateVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuState(
        verifier,  values->Get(i), types->GetEnum<uState>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyuCommand(flatbuffers::Verifier &verifier, const void *obj, uCommand type) {
  switch (type) {
    case uCommand_NONE: {
      return true;
    }
    case uCommand_tBlindCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tBlindCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uCommand_tSinglePwmCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tSinglePwmCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uCommand_tOnOffCommand: {
      auto ptr = reinterpret_cast<const sensact::comm::tOnOffCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyuCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuCommand(
        verifier,  values->Get(i), types->GetEnum<uCommand>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyuConfig(flatbuffers::Verifier &verifier, const void *obj, uConfig type) {
  switch (type) {
    case uConfig_NONE: {
      return true;
    }
    case uConfig_tBlindConfig: {
      auto ptr = reinterpret_cast<const sensact::comm::tBlindConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uConfig_tSinglePwmConfig: {
      auto ptr = reinterpret_cast<const sensact::comm::tSinglePwmConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case uConfig_tOnOffConfig: {
      auto ptr = reinterpret_cast<const sensact::comm::tOnOffConfig *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyuConfigVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuConfig(
        verifier,  values->Get(i), types->GetEnum<uConfig>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace comm
}  // namespace sensact

#endif  // FLATBUFFERS_GENERATED_WEBUICORECOMM_SENSACT_COMM_H_
